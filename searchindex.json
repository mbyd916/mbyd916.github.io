{"categories":[{"title":"GitHub","uri":"https://blog.marvel6.cn/categories/github/"},{"title":"Golang","uri":"https://blog.marvel6.cn/categories/golang/"},{"title":"Leetcode 题解","uri":"https://blog.marvel6.cn/categories/leetcode-%E9%A2%98%E8%A7%A3/"},{"title":"单元测试","uri":"https://blog.marvel6.cn/categories/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"},{"title":"基础组件","uri":"https://blog.marvel6.cn/categories/%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6/"},{"title":"备忘","uri":"https://blog.marvel6.cn/categories/%E5%A4%87%E5%BF%98/"},{"title":"并发","uri":"https://blog.marvel6.cn/categories/%E5%B9%B6%E5%8F%91/"},{"title":"技巧","uri":"https://blog.marvel6.cn/categories/%E6%8A%80%E5%B7%A7/"},{"title":"相册","uri":"https://blog.marvel6.cn/categories/%E7%9B%B8%E5%86%8C/"},{"title":"笔记","uri":"https://blog.marvel6.cn/categories/%E7%AC%94%E8%AE%B0/"},{"title":"翻译","uri":"https://blog.marvel6.cn/categories/%E7%BF%BB%E8%AF%91/"}],"posts":[{"content":" 香克斯 香克斯 香克斯 ","id":0,"section":"posts","summary":"\u003cdiv data-nanogallery2='{\n\t \"thumbnailDisplayTransition\":          \"none\",\n     \"thumbnailDisplayTransitionDuration\":  500,\n     \"thumbnailDisplayInterval\":            30,\n     \"galleryDisplayTransition\":            \"none\",\n     \"galleryDisplayTransitionDuration\":    500,\n     \"galleryDisplayMode\": \"rows\",\n     \"thumbnailDisplayOutsideScreen\": \"false\",\n     \"eventsDebounceDelay\": 10,\n     \"thumbnailL1BorderHorizontal\": 0,\n     \"thumbnailL1BorderVertical\": 0,\n     \"thumbnailLabel\": {\n        \"titleFontSize\": \"0.6em\"\n     },\n     \"thumbnailHoverEffect2\": \"image_scale_1.00_1.10|label_backgroundColor_rgba(0,0,0,0)_rgba(255,255,255,0)\",\n     \"galleryTheme\": {\n        \"thumbnail\": {\n            \"borderRadius\": \"8px\"\n        }\n     },\n     \"thumbnailToolbarImage\": {\n        \"topLeft\": \"\",\n        \"topRight\": \"\",\n        \"bottomLeft\": \"\",\n        \"bottomRight\": \"\"\n     },\n     \"viewerToolbar\":   {\n        \"display\": true,\n        \"standard\": \"label\"\n     },\n     \"viewerTools\":     {\n        \"topLeft\":    \"pageCounter, playPauseButton\",\n        \"topRight\":   \"downloadButton, rotateLeft, zoomButton, fullscreenButton, closeButton\"\n     },\n     \"viewerGalleryTWidth\": 40,\n     \"viewerGalleryTHeight\": 40\n}'\u003e\n    \n\u003ca href=\"https://www.sulvblog.cn/image/16_IMG_20220430_202353.png\" data-ngThumb=\"https://www.sulvblog.cn/image/16_IMG_20220430_202353.png\"\u003e香克斯\u003c/a\u003e\n\u003ca href=\"https://www.sulvblog.cn/image/17_IMG_20220430_202228.png\" data-ngThumb=\"https://www.sulvblog.cn/image/17_IMG_20220430_202228.png\"\u003e\u003c/a\u003e\n\u003ca href=\"https://www.sulvblog.cn/image/19_IMG_20220430_200901.png\" data-ngThumb=\"https://www.sulvblog.cn/image/19_IMG_20220430_200901.png\"\u003e\u003c/a\u003e\n\u003ca href=\"https://www.sulvblog.cn/image/16_IMG_20220430_202353.png\" data-ngThumb=\"https://www.sulvblog.cn/image/16_IMG_20220430_202353.png\"\u003e香克斯\u003c/a\u003e\n\u003ca href=\"https://www.sulvblog.cn/image/17_IMG_20220430_202228.png\" data-ngThumb=\"https://www.sulvblog.cn/image/17_IMG_20220430_202228.png\"\u003e\u003c/a\u003e\n\u003ca href=\"https://www.sulvblog.cn/image/19_IMG_20220430_200901.png\" data-ngThumb=\"https://www.sulvblog.cn/image/19_IMG_20220430_200901.png\"\u003e\u003c/a\u003e\n\u003ca href=\"https://www.sulvblog.cn/image/16_IMG_20220430_202353.png\" data-ngThumb=\"https://www.sulvblog.cn/image/16_IMG_20220430_202353.png\"\u003e香克斯\u003c/a\u003e\n\u003ca href=\"https://www.sulvblog.cn/image/17_IMG_20220430_202228.png\" data-ngThumb=\"https://www.sulvblog.cn/image/17_IMG_20220430_202228.png\"\u003e\u003c/a\u003e\n\u003ca href=\"https://www.sulvblog.cn/image/19_IMG_20220430_200901.png\" data-ngThumb=\"https://www.sulvblog.cn/image/19_IMG_20220430_200901.png\"\u003e\u003c/a\u003e\n\n\u003c/div\u003e","tags":["功能测试"],"title":"给博客支持相册功能并测试","uri":"https://blog.marvel6.cn/2024/09/test_gallery_support/","year":"2024"},{"content":"任何语言，错误处理都是至关重要的，开发人员只有学会正确地处理错误，才可能写出健壮的程序。本文主要介绍使用 Golang 这门语言在错误处理方面的一些实践，首先来看一下我们可能遇到的一些问题。\n问题 Go 代码中常见的错误处理片段，被不少人诟病，可能处理业务逻辑的核心代码没几行，类似语句却写了一大堆 :-(\nif err != nil { return err } 或者（当然，还有这样的，仅抛给上层调用方哪儿够，得自己也打印一份日志 :-) ）\nif err != nil { logs.CtxError(ctx, \u0026#34;failed to xxx: %s\u0026#34;, err) return err } 错误处理是很重要的，Go 语言鼓励开发人员当可能发生错误时，去明确地检查错误，这可能使得代码很冗长，不过本文介绍的一些方法可以简化重复的错误处理工作。\n（吐槽时间） (balabalabala\u0026hellip;)\n总结一下：\n缺少错误上下文和堆栈信息； 冗余，代码冗长，主逻辑割裂； 分层开发，日志泛滥； 是什么 接下来先了解一下 Go 的 error 类型，然后我们再想办法逐一解决上述问题。Go 社区流行很多“谚语”，其中有一句和“错误”有关的，来自 Go 语言合作者 Rob Pike 大神。\nErrors are values.\nby Rob Pike\nerror 是内置类型，定义为一个 interface。\ntype error interface { Error() string } 标准库 errors 包提供了一个默认错误类型 errorString，借助一个字符串字段保存错误信息，开发者可以通过 errors.New(\u0026quot;xyz\u0026quot;) 创建一个“标准”错误。\n// New returns an error that formats as the given text. // Each call to New returns a distinct error value even if the text is identical. func New(text string) error { return \u0026amp;errorString{text} } // errorString is a trivial implementation of error. type errorString struct { s string } func (e *errorString) Error() string { return e.s } 此外，fmt 包还提供了一个函数 Errorf，用来创建格式化“错误”，允许开发人员添加一些上下文信息，这种方法更常用。\n当然，开发者也可以自定义错误类型，通过实现 error 接口，为程序“错误”提供更详细的上下文信息， 如标准库的 PathError：\n// PathError records an error and the operation and // file path that caused it. type PathError struct { Op string // \u0026#34;open\u0026#34;, \u0026#34;unlink\u0026#34;, etc. Path string // The associated file. Err error // Returned by the system call. } func (e *PathError) Error() string { return e.Op + \u0026#34; \u0026#34; + e.Path + \u0026#34;: \u0026#34; + e.Err.Error() } 调用出错（如打开一个不存在的文件）时，可能看到的提示：\nopen /not_exists: no such file or directory 此外，还可以通过类型断言获取具体错误类型，进行检查并处理。\nfor try := 0; try \u0026lt; 2; try++ { file, err = os.Create(filename) if err == nil { return } if e, ok := err.(*os.PathError); ok \u0026amp;\u0026amp; e.Err == syscall.ENOSPC { deleteTempFiles() // Recover some space. continue } return } 为什么 我们再来简单看下 Go 语言的前辈们是如何处理错误的？一般有两种方法：\n返回值检查 异常机制 分别以 C 和 Java 两种语言将“字符串转为整型”为例进行说明：\n// 当返回值=0，无法区分转换是否成功 int atoi(const char *str); // 通过errno、返回值以及出参endptr判断 long int strtol(const char *nptr, char **endptr, int base); // errno: // EINVAL // ERANGE // result = strtol(value, \u0026amp;eptr, 10); if (result == 0) { if (errno == EINVAL) { printf(\u0026#34;Conversion error occurred: %d\\n\u0026#34;, errno); exit(0); } } if (result == LONG_MIN || result == LONG_MAX) { if (errno == ERANGE) printf(\u0026#34;The value provided was out of range\\n\u0026#34;); } //... C 只能有一个返回值\n无法区分正常和异常返回； 引入“出参”形式，函数声明变得更复杂； // 抛异常 public static int parseInt(String s, int radix) throws NumberFormatException try { int result = Integer.parseInt(\u0026#34;123abcd\u0026#34;, 10); System.out.println(result); // other logic } catch (Exception e) { e.printStackTrace(); } // java.lang.NumberFormatException: For input string: \u0026#34;123abcd\u0026#34; // at java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:68) // at java.base/java.lang.Integer.parseInt(Integer.java:652) // at Hello.main(Hello.java:6) Java 异常机制 try-catch-finally\n错误处理和返回值完全分开； 正常代码与错误处理逻辑分开，提高可读性； “受检”异常不能被忽略，需要显示声明并处理。 func Atoi(s string) (int, error) func ParseInt(s string, base int, bitSize int) (i int64, err error) result, err := strconv.ParseInt(\u0026#34;123abcd\u0026#34;, 10, 64) if err != nil { fmt.Println(err) return } // strconv.ParseInt: parsing \u0026#34;123abcd\u0026#34;: invalid syntax Go 错误处理本质上也是通过检查返回值实现的，不过：\nGo 支持多值返回，可以将业务返回值和错误返回值区分开； 可以用 _ 显式忽略错误； 并且定义了内置的 error 类型，方便开发者进行扩展； 使用“异常”有不少优势，为啥 Go 不这么做呢？\n我们认为，将“异常”处理耦合到控制结构（如 try-catch-finally）会导致代码混乱。它还倾向于鼓励程序员将太多的常见错误（例如，无法打开文件）标记为“异常”的。\nFrom Go 官方 FAQ\nWhy Go Gets Exceptions Right?\n那么 Go 认为的“异常”情况是怎样的呢？\n当 Go 程序出现不可恢复的运行时错误，会抛出 panic（直译“恐慌”），如：\n索引越界； 类型断言失败等； 注：一般不建议使用 panic 作为 Go 的错误处理方法。\n不过初始化程序时可以使用，如程序启动依赖的必要条件不能满足时：\nvar user = os.Getenv(\u0026#34;USER\u0026#34;) func init() { if user == \u0026#34;\u0026#34; { panic(\u0026#34;no value for $USER\u0026#34;) } } 怎么做 接下来我们来看下如何解决一开始提到的问题：\n1. 常用包 Dave pkg/errors Go 1.3 或以上标准库 errors和 fmt 推荐第1种，能记录错误堆栈信息；\n标准库 errors 使用举例：\nfunc main() { e1 := errors.New(\u0026#34;1st error\u0026#34;) e2 := fmt.Errorf(\u0026#34;2nd: %w\u0026#34;, e1) e3 := fmt.Errorf(\u0026#34;3rd: %w\u0026#34;, e2) e4 := fmt.Errorf(\u0026#34;4th: %w\u0026#34;, e3) fmt.Println(e1) fmt.Println(e2) fmt.Println(e3) fmt.Println(e4) fmt.Println(\u0026#34;====================================\u0026#34;) e5 := errors.Unwrap(e4) fmt.Println(\u0026#34;e5 == e3?\u0026#34;, e5 == e3) fmt.Println(\u0026#34;e5 Is e3?\u0026#34;, errors.Is(e5, e3)) fmt.Println(\u0026#34;====================================\u0026#34;) fmt.Println(\u0026#34;e5 == e1?\u0026#34;, e5 == e1) fmt.Println(\u0026#34;e5 Is e1?\u0026#34;, errors.Is(e5, e1)) // output: // 1st error // 2nd: 1st error // 3rd: 2nd: 1st error // 4th: 3rd: 2nd: 1st error // ==================================== // e5 == e3? true // e5 Is e3? true // ==================================== // e5 == e1? false // e5 Is e1? true } type MyError struct { err string } func (e *MyError) Error() string { return e.err } func main() { e1 := \u0026amp;MyError{\u0026#34;1st error\u0026#34;} e2 := fmt.Errorf(\u0026#34;2nd: %w\u0026#34;, e1) e3 := fmt.Errorf(\u0026#34;3rd: %w\u0026#34;, e2) e4 := fmt.Errorf(\u0026#34;4th: %w\u0026#34;, e3) fmt.Println(e1) fmt.Println(e2) fmt.Println(e3) fmt.Println(e4) fmt.Println(\u0026#34;====================================\u0026#34;) var err5 *MyError fmt.Println(errors.As(e4, \u0026amp;err5)) fmt.Println(err5) // output: // 1st error // 2nd: 1st error // 3rd: 2nd: 1st error // 4th: 3rd: 2nd: 1st error // ==================================== // true // 1st error } 2. 更优雅地处理错误 示例 1：统计文件行数\nfunc CountLines(r io.Reader) (int, error) { var ( br = bufio.NewReader(r) lines int err error ) for { _, err = br.ReadString(\u0026#39;\\n\u0026#39;) lines++ if err != nil { break } } if err != io.EOF { return 0, err } return lines, nil } (注：仅作错误处理说明用，以上代码存在 bug，如空文件，统计行数为 1)\n我们也许可以从标准库 bufio 包 Scanner 类型找找灵感，Scan 方法并未直接返回 error 类型，而是返回了一个 boolean 类型，还提供了一个 Err 方法返回发生的错误。\nfunc CountLines(r io.Reader) (int, error) { sc := bufio.NewScanner(r) lines := 0 for sc.Scan() { lines++ } return lines, sc.Err() } 将错误处理与主流程分开，提升代码可读性。\n示例 2:\ntype Header struct { Key, Value string } type Status struct { Code int Reason string } func WriteResponse(w io.Writer, st Status, headers []Header, body io.Reader) error { _, err := fmt.Fprintf(w, \u0026#34;HTTP/1.1 %d %s\\r\\n\u0026#34;, st.Code, st.Reason) if err != nil { return err } for _, h := range headers { _, err := fmt.Fprintf(w, \u0026#34;%s: %s\\r\\n\u0026#34;, h.Key, h.Value) if err != nil { return err } } if _, err := fmt.Fprint(w, \u0026#34;\\r\\n\u0026#34;); err != nil { return err } _, err = io.Copy(w, body) return err } 改造之后\ntype errWriter struct { io.Writer err error } func (e *errWriter) Write(buf []byte) (int, error) { if e.err != nil { return 0, e.err } var n int n, e.err = e.Writer.Write(buf) return n, nil } func WriteResponse(w io.Writer, st Status, headers []Header, body io.Reader) error { ew := \u0026amp;errWriter{Writer: w} fmt.Fprintf(ew, \u0026#34;HTTP/1.1 %d %s\\r\\n\u0026#34;, st.Code, st.Reason) for _, h := range headers { fmt.Fprintf(ew, \u0026#34;%s: %s\\r\\n\u0026#34;, h.Key, h.Value) } fmt.Fprint(ew, \u0026#34;\\r\\n\u0026#34;) io.Copy(ew, body) return ew.err } 另外大家用到的 Gorm 框架，能进行链式调用，也采用了类似的实现思路。\n// DB GORM DB definition type DB struct { *Config Error error RowsAffected int64 Statement *Statement clone int } lead := \u0026amp;Lead{LockState: Unlocked} db.WithContext(ctx).Table(tbl). Select(\u0026#34;lock_state\u0026#34;). Where(\u0026#34;id=? AND lock_state=?\u0026#34;, id, Locked).Updates(lead).Error 每一个方法都返回*DB类型，没有额外返回error。\n3. 仅在最上层调用打日志 func main() { err := parseConf(\u0026#34;not_exist.json\u0026#34;) if err != nil { log.Printf(\u0026#34;parse conf: %s\u0026#34;, err) return } } func parseConf(name string) error { content, err := readFile(name) if err != nil { log.Printf(\u0026#34;read file: %s\u0026#34;, err) return err } // Parse JSON content. _ = content return nil } func readFile(name string) ([]byte, error) { f, err := os.Open(name) if err != nil { log.Printf(\u0026#34;open file: %s\u0026#34;, err) return nil, err } defer f.Close() buf := make([]byte, 0, 512) // Read the file. return buf, nil } // 2021/05/14 18:43:05 open file: open not_exist.json: no such file or directory // 2021/05/14 18:43:05 read file: open not_exist.json: no such file or directory // 2021/05/14 18:43:05 parse conf: open not_exist.json: no such file or directory package main import ( \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;github.com/pkg/errors\u0026#34; ) func main() { err := parseConf(\u0026#34;not_exist.json\u0026#34;) if err != nil { log.Printf(\u0026#34;parse conf: %+v\u0026#34;, err) return } } func parseConf(name string) error { content, err := readFile(name) if err != nil { return err } // Parse JSON content. _ = content return nil } func readFile(name string) ([]byte, error) { f, err := os.Open(name) if err != nil { return nil, errors.Wrap(err, \u0026#34;open file\u0026#34;) } defer f.Close() buf := make([]byte, 0, 512) // Read the file. return buf, nil } // 2021/05/14 18:46:36 parse conf: open not_exist.json: no such file or directory // open file // main.readFile // /Users/marvel/Workspace/errors/test.go:32 // main.parseConf // /Users/marvel/Workspace/errors/test.go:19 // main.main // /Users/marvel/Workspace/errors/test.go:11 // runtime.main // /Users/marvel/sdk/go1.16/src/runtime/proc.go:225 // runtime.goexit // /Users/marvel/sdk/go1.16/src/runtime/asm_amd64.s:1371 HTTP 服务还可以利用日志中间件实现，在 API 最顶层打印日志。\n4. 通过 panic 和 recover 进行错误处理 // Error is the type of a parse error; it satisfies the error interface. type Error string func (e Error) Error() string { return string(e) } // error is a method of *Regexp that reports parsing errors by // panicking with an Error. func (regexp *Regexp) error(err string) { panic(Error(err)) } // Compile returns a parsed representation of the regular expression. func Compile(str string) (regexp *Regexp, err error) { regexp = new(Regexp) // doParse will panic if there is a parse error. defer func() { if e := recover(); e != nil { regexp = nil // Clear return value. err = e.(Error) // Will re-panic if not a parse error. } }() return regexp.doParse(str), nil } recover 只能在 defer 函数体内使用。\nif pos == 0 { re.error(\u0026#34;\u0026#39;*\u0026#39; illegal at start of expression\u0026#34;) } 局限性：只能用在同一个包内，将内部产生的 panic 转为 error 返回给调用者；而不能主动抛 panic 给调用者。\n5. 并发场景下的错误处理 可以使用官方工具包 errgroup ，对 sync.WaitGroup 进行了巧妙的封装，简化了同步处理逻辑，同时允许并发执行的子任务将可能出现的错误返回给调用方。\nfunc main() { g := new(errgroup.Group) var urls = []string{ \u0026#34;http://www.golang.org/\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;, \u0026#34;http://www.somestupidname.com/\u0026#34;, } for _, url := range urls { // Launch a goroutine to fetch the URL. url := url // https://golang.org/doc/faq#closures_and_goroutines g.Go(func() error { // Fetch the URL. resp, err := http.Get(url) if err == nil { resp.Body.Close() } return err }) } // Wait for all HTTP fetches to complete. if err := g.Wait(); err == nil { fmt.Println(\u0026#34;Successfully fetched all URLs.\u0026#34;) } } 6. 一些规范 错误描述小写开头，加前缀（如包名），如 image: unknown format\n自定义错误类型以 Error 结尾，变量以 Err 或 err 开头；\n函数（或方法）最后一个返回值返回 error 类型，不要返回具体的错误类型；\n自定义 Error 接口，包含其他判别具体错误的方法；\npackage net type Error interface { error Timeout() bool // Is the error a timeout? Temporary() bool // Is the error temporary? } 7. 特别注意的坑 type MyError struct { code int msg string } func (e *MyError) Error() string { return fmt.Sprintf(\u0026#34;code=%d, msg=%s\u0026#34;, e.code, e.msg) } var ErrBad = \u0026amp;MyError{code: 500, msg: \u0026#34;something bad occurs\u0026#34;} // Bad func Handle() error { var err *MyError = nil if bad() { err = ErrBad } return err } // Good func Handle() error { if bad() { return ErrBad } return nil } 参考 https://golang.org/doc/effective_go#errors https://blog.golang.org/error-handling-and-go https://blog.golang.org/errors-are-values https://github.com/golang/go/wiki/Errors https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully https://dave.cheney.net/2019/01/27/eliminate-error-handling-by-eliminating-errors https://blog.golang.org/go1.13-errors https://www.sohu.com/a/342949702_657921 Go语言中的错误处理（Error Handling in Go） https://dave.cheney.net/paste/gocon-spring-2016.pdf https://coolshell.cn/articles/21140.html https://blog.golang.org/defer-panic-and-recover ","id":1,"section":"posts","summary":"\u003cp\u003e任何语言，错误处理都是至关重要的，开发人员只有学会正确地处理错误，才可能写出健壮的程序。本文主要介绍使用 Golang 这门语言在错误处理方面的一些实践，首先来看一下我们可能遇到的一些问题。\u003c/p\u003e","tags":["错误处理"],"title":"Golang 错误处理实践","uri":"https://blog.marvel6.cn/2021/06/golang-error-handle-practice/","year":"2021"},{"content":"一直以来，团队同学（也包括我自己）对单元测试不够重视，代码覆盖率几乎等于 0， 最直接的后果是代码 bug 率较高，重构困难。从 PHP 转为 Golang 开发已有一年多，进行过多次微服务架构优化，每次进行代码重构，鲜有单元测试，大多进行接口级别的集成测试。不够全面，测试用例也没和代码放在一起维护，后续逻辑调整，原测试用例几乎废掉。为了改变现状，认真调研了 Golang 生态的单元测试和 Mock 工具，因为业务逻辑大多离不开数据库的 CRUD 操作，所以本文先从简单的 Sql Mock 谈起。\n我们使用 Xorm 包进行 CRUD 操作，简单易用。经过调研，使用 Goconvey 作为单元测试框架，兼容 Golang 原生的测试框架，同时具备“断言”等功能。使用 Sqlmock 作为 DB mock 框架。使用 gomonkey 作为通用的 mock 工具，可以 mock 函数、方法和变量等。\n接下来通过一个简单的例子来介绍如何使用 Goconvey 和 Sqlmock 进行单元测试和 mock。代码逻辑实现对表person的 CRUD 操作，先定义一个结构体（带 xorm tag 定义）：\ntype Person struct { ID int `xorm:\u0026#34;pk id\u0026#34;` Name string `xorm:\u0026#34;name\u0026#34;` } func (p *Person) TableName() string { return \u0026#34;person\u0026#34; } 然后定义一个接口，提供对Person的 CRUD 操作：\ntype Repository interface { Get(id int) (*Person, error) Create(id int, name string) error Update(id int, name string) error Delete(id int) error } 简单实现上面定义的接口，利用 xorm 提供的 API，能快速实现 CRUD 操作：\ntype repo struct { session *xorm.Session } func NewPersonRepo(session *xorm.Session) Repository { return repo{session} } func (r repo) Get(id int) (person *Person, err error) { person = \u0026amp;Person{ID: id} has, err := r.session.Get(person) if err != nil { return } if !has { err = fmt.Errorf(\u0026#34;person[id=%d] not found\u0026#34;, id) return } return } func (r repo) Create(id int, name string) (err error) { person := \u0026amp;Person{ID: id, Name: name} affected, err := r.session.Insert(person) if err != nil { return } if affected == 0 { err = fmt.Errorf(\u0026#34;insert err, because of 0 affected\u0026#34;) return } return } // 省略 Update 和 Delete 的实现 ... 下面才是本文的重点，来进行单元测试和 Mock： 通过 sqlmock 可以获取sql.DB和 mock 对象\ndb, mock, err := sqlmock.New() 以 MySQL 为例进行 mock，以下是 xorm 创建 engine 的方法：\neng, err := xorm.NewEngine(\u0026#34;mysql\u0026#34;, \u0026#34;root:123@/test?charset=utf8\u0026#34;) 如何把db和eng关联起来呢？ 查看 xorm 创建 engine 的源码发现，其实 engine 底层封装了sql.DB对象。通过下面的操作就可以把二者关联起来。\neng.DB().DB = db // 默认在标准输出打印SQL，方便调试 eng.ShowSQL(true) 通过 sqlmock 获取 xorm engine（Session） 的完整代码如下：\nfunc getSession() (*xorm.Session, sqlmock.Sqlmock) { db, mock, err := sqlmock.New() So(err, ShouldBeNil) eng, err := xorm.NewEngine(\u0026#34;mysql\u0026#34;, \u0026#34;root:123@/test?charset=utf8\u0026#34;) So(err, ShouldBeNil) eng.DB().DB = db eng.ShowSQL(true) return eng.NewSession(), mock } 至此，mock 准备工作已经完成啦。\n首先来看查询 SQL 语句的 mock 实现：\nConvey 框架有三个关键函数：Convey、So 和Reset。\nConvey 新创建一个单元测试域，Convey 可以嵌套，每次执行被嵌套的子语句之前，都会先执行一遍外部的 Convey 语句，从而能实现其他测试套件类似的 Setup 效果。 So 进行断言 Reset 每次执行完 case 后进行清理工作。 mock 对象提供了一组方法，实现 Sql mock。首先是ExpectQuery方法，指定查询的 Sql 语句，可以提供正则表达式，默认通过正则匹配。WithArgs指定 Sql 的参数，WillReturnRows设置期待返回的查询结果。每次执行完 case，都会执行ExpectationsWereMet判断所有的 Sql mock 是否被满足。\nfunc TestPersonGet(t *testing.T) { Convey(\u0026#34;Setup\u0026#34;, t, func() { session, mock := getSession() repo := NewPersonRepo(session) id, name := 1, \u0026#34;John\u0026#34; Convey(\u0026#34;get some person by id\u0026#34;, func() { mock.ExpectQuery(\u0026#34;SELECT (.+) FROM `person`\u0026#34;). WithArgs(id). WillReturnRows(sqlmock.NewRows([]string{\u0026#34;id\u0026#34;, \u0026#34;name\u0026#34;}).AddRow(id, name)) person, err := repo.Get(id) So(err, ShouldBeNil) So(person, ShouldResemble, \u0026amp;Person{ID: id, Name: name}) }) Convey(\u0026#34;get none person by id\u0026#34;, func() { mock.ExpectQuery(\u0026#34;SELECT (.+) FROM `person`\u0026#34;). WithArgs(id). WillReturnRows(sqlmock.NewRows([]string{\u0026#34;id\u0026#34;, \u0026#34;name\u0026#34;})) person, err := repo.Get(id) So(err, ShouldBeError) So(person, ShouldResemble, \u0026amp;Person{ID: id}) }) Reset(func() { So(mock.ExpectationsWereMet(), ShouldBeNil) }) }) } 再来看执行语句的 mock，这里以insert为例，更新和删除操作类似。与查询语句不同的地方需要使用ExpectExec方法指定 SQL，WillReturnResult指定期待返回的执行结果。（最近插入的自增 id 和 affected 的值）\nfunc TestPersonCreate(t *testing.T) { Convey(\u0026#34;Setup\u0026#34;, t, func() { session, mock := getSession() repo := NewPersonRepo(session) id, name := 1, \u0026#34;John\u0026#34; Convey(\u0026#34;create a person\u0026#34;, func() { mock.ExpectExec(\u0026#34;INSERT INTO `person`\u0026#34;). WithArgs(id, name). WillReturnResult(sqlmock.NewResult(1, 1)) err := repo.Create(id, name) So(err, ShouldBeNil) }) Convey(\u0026#34;create none person\u0026#34;, func() { mock.ExpectExec(\u0026#34;INSERT INTO `person`\u0026#34;). WithArgs(id, name). WillReturnResult(sqlmock.NewResult(0, 0)) err := repo.Create(id, name) So(err, ShouldBeError) }) Reset(func() { So(mock.ExpectationsWereMet(), ShouldBeNil) }) }) } 至此，整个单元测试和 Mock 示例就介绍完了。可以通过下列命令执行单元测试，并统计代码覆盖率。\ngo test -v -cover 部分输出如下：\n=== RUN TestPersonGet Setup ✔✔ get some person by id [xorm] [info] 2020/01/23 22:48:02.349268 [SQL] SELECT `id`, `name` FROM `person` WHERE `id`=? LIMIT 1 []interface {}{1} ✔✔✔✔✔ get none person by id [xorm] [info] 2020/01/23 22:48:02.349908 [SQL] SELECT `id`, `name` FROM `person` WHERE `id`=? LIMIT 1 []interface {}{1} ✔✔✔ 10 total assertions --- PASS: TestPersonGet (0.00s) === RUN TestPersonCreate [root@VM_193_77_centos /data/go_dev/mock_db_by_xorm]# go test -v -cover === RUN TestPersonGet Setup ✔✔ get some person by id [xorm] [info] 2020/01/23 22:49:58.951607 [SQL] SELECT `id`, `name` FROM `person` WHERE `id`=? LIMIT 1 []interface {}{1} ✔✔✔✔✔ get none person by id [xorm] [info] 2020/01/23 22:49:58.952026 [SQL] SELECT `id`, `name` FROM `person` WHERE `id`=? LIMIT 1 []interface {}{1} ✔✔✔ 10 total assertions --- PASS: TestPersonGet (0.00s) === RUN TestPersonCreate Setup ✔✔ create a person [xorm] [info] 2020/01/23 22:49:58.952577 [SQL] INSERT INTO `person` (`id`,`name`) VALUES (?, ?) []interface {}{1, \u0026#34;John\u0026#34;} ✔✔✔✔ create none person [xorm] [info] 2020/01/23 22:49:58.952898 [SQL] INSERT INTO `person` (`id`,`name`) VALUES (?, ?) []interface {}{1, \u0026#34;John\u0026#34;} ✔✔ 18 total assertions --- PASS: TestPersonCreate (0.00s) ... PASS coverage: 90.9% of statements ok github.com/mbyd916/dbmock 0.007s 可以看到上述测试 DEMO 覆盖度达 90.9%。后续会介绍更多的单元测试示例，敬请期待:-)\n参考 xorm 官方文档 goconvey 官方文档 sqlmock 官方文档 示例完整代码 ","id":2,"section":"posts","summary":"\u003cp\u003e一直以来，团队同学（也包括我自己）对单元测试不够重视，代码覆盖率几乎等于 0， 最直接的后果是代码 bug 率较高，重构困难。从 PHP 转为 Golang 开发已有一年多，进行过多次微服务架构优化，每次进行代码重构，鲜有单元测试，大多进行接口级别的集成测试。不够全面，测试用例也没和代码放在一起维护，后续逻辑调整，原测试用例几乎废掉。为了改变现状，认真调研了 Golang 生态的单元测试和 Mock 工具，因为业务逻辑大多离不开数据库的 CRUD 操作，所以本文先从简单的 Sql Mock 谈起。\u003c/p\u003e","tags":["Sqlmock","Xorm","Goconvey"],"title":"借助 Goconvey 和 Sqlmock 对基于 Xorm 的 DB 操作进行单元测试和 Mock","uri":"https://blog.marvel6.cn/2020/01/test-and-mock-db-by-xorm-with-the-help-of-convey-and-sqlmock/","year":"2020"},{"content":"hystrix 是 Netflix 开源的一个非常强大的熔断降级组件， 用 Java 实现， 而 hystrix-go 是其 Go 版本的一个实现。本文主要介绍 Command 配置涉及的 5 个参数。\nCommandConfig 结构体如下：\ntype CommandConfig struct { Timeout int `json:\u0026#34;timeout\u0026#34;` MaxConcurrentRequests int `json:\u0026#34;max_concurrent_requests\u0026#34;` RequestVolumeThreshold int `json:\u0026#34;request_volume_threshold\u0026#34;` SleepWindow int `json:\u0026#34;sleep_window\u0026#34;` ErrorPercentThreshold int `json:\u0026#34;error_percent_threshold\u0026#34;` } 有 5 个参数可供配置，下面介绍他们的具体含义：\nTimeout: 设置调用方执行超时，默认设置 1000 ms。超时后，hystrix 执行降级处理。\nMaxConcurrentRequests: 设置调用方最大并发限制，默认值是 10。超过后，hystrix 执行降级处理。\nRequestVolumeThreshold：在滑动窗口的采样时间内，请求次数达到这个阈值后，才开始判断是否熔断，默认值是 20。举例来说，如果该值是 20，在 10s 的滑动窗口期收到了 19 个请求，即使全都失败了，也不会触发熔断。\nSleepWindow：休眠窗口期，默认设置 5000ms。熔断后等待试探（是否关闭熔断器）的时间。\nErrorPercentThreshold：错误率阈值，默认是 50。超过后，会启用熔断和降级处理。\n按上述 Command 的默认配置，熔断器生效的条件是：\n在 10s 内，至少需要接收到 20 个请求（RequestVolumeThreshold），并且有一定比例（ErrorPercentThreshold）的请求处理失败了，这样熔断器才会被打开。5s 后（SleepWindow），处理第 1 个请求，如果成功，熔断器将会关闭，开始正常对外提供服务。\n参考 Hystrix Configuration 官方文档\nHystrix Circuit Breaker — How To Set It Up Properly\n","id":3,"section":"posts","summary":"\u003cp\u003ehystrix 是 Netflix 开源的一个非常强大的熔断降级组件， 用 Java 实现， 而 hystrix-go 是其 Go 版本的一个实现。本文主要介绍 Command 配置涉及的 5 个参数。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eCommandConfig\u003c/code\u003e 结构体如下：\u003c/p\u003e","tags":["Hystrix 配置","熔断降级"],"title":"详解 hystrix-go Command 配置参数","uri":"https://blog.marvel6.cn/2019/12/hystrixgo-command-config-introduction/","year":"2019"},{"content":"问题 给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, \u0026hellip;）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。\n示例 1:\n输入：n = 12\n输出：3\n解释：12 = 4 + 4 + 4.\n示例 2:\n输入：n = 13\n输出：2\n解释：13 = 4 + 9.\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/perfect-squares\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n思路 用动态规划解决这道题，记 f(i)，为将 i 表达成若干个完全平方数和所需要的完全平方数的最小个数。\n从 1 到 n 求每个整数 i，对应的 f(i)。对于整数 i，j 从 1 开始，j*j 不超过 i，状态转移方程：\n$f(i) = \\min\\limits_{1\\leq\\ jj\\ \\leq i} {f(i-jj)+1} $\n代码 func numSquares(n int) int { f := make([]int, n+1) for i := 1; i \u0026lt;= n; i++ { // 最坏情况，等于 i 个 1 的和 f[i] = i for j := 1; j*j \u0026lt;= i; j++ { f[i] = min(f[i], f[i - j*j]+1) } } return f[n] } func min(a, b int) int { if a \u0026lt; b { return a } return b } ","id":4,"section":"posts","summary":"\u003ch3 id=\"问题\"\u003e问题\u003c/h3\u003e\n\u003cp\u003e给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, \u0026hellip;）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。\u003c/p\u003e","tags":["数学","动态规划"],"title":"Leetcode 题解：完全平方数","uri":"https://blog.marvel6.cn/2019/12/leetcode-perfect-squares/","year":"2019"},{"content":"背景 我用Hugo生成的静态博客部署在腾讯云CVM上，只有一个实例，存在单点风险，也不能实现负载均衡。所以想托管在GitHub Pages，本文简单记录实现过程。\n1. 在Github 创建两个代码库 首先我创建了以下两个代码库：\nblog-hg 托管博客原内容（Hugo 站点）\nmbyd916.github.io 托管生成的静态页面\n2. 添加 git 子模块 把第二个代码库作为第一个的子模块，具体来说，把Hugo站点 public 目录设置为引用子模块。\ngit submodule add https://github.com/mbyd916/mbyd916.github.io.git public 3. 添加部署脚本 在 blog-hg 代码库添加以下脚本文件，通过hugo 重新生成静态博客后，再把静态内容推送到代码库 mbyd916.github.io。\n#!/bin/bash echo -e \u0026#34;\\033[0;32mDeploying updates to GitHub...\\033[0m\u0026#34; # Build the project. hugo # if using a theme, replace by `hugo -t \u0026lt;yourtheme\u0026gt;` # Go To Public folder cd public # Add changes to git. git add -A # Commit changes. msg=\u0026#34;rebuilding site `date`\u0026#34; if [ $# -eq 1 ] then msg=\u0026#34;$1\u0026#34; fi git commit -m \u0026#34;$msg\u0026#34; # Push source and build repos. git push origin master # Come Back cd .. 完成这步后，我的静态博客就可以通过 https://mbyd916.github.io 访问啦 :-)\n4. 关联我的域名 最后还想通过自己的域名访问该站点，GitHub Pages 提供设置个性化域名的功能。\n进入mbyd916.github.io代码库设置，找到 GitHub Pages 相关配置。\n填写域名并保存，这时会在代码库新增一个文件CNAME，文件内容为：\nblog.marvel6.cn 接下来还需要在腾讯云域名解析，新增一条 CNAME 记录，从 blog.marvel6.cn 指向 mbyd916.github.io。\n配置后，通过 dig 查看是否生效；\ndig blog.marvel6.cn +nostats +nocomments +nocmd ; \u0026lt;\u0026lt;\u0026gt;\u0026gt; DiG 9.10.6 \u0026lt;\u0026lt;\u0026gt;\u0026gt; blog.marvel6.cn +nostats +nocomments +nocmd ;; global options: +cmd ;blog.marvel6.cn.\tIN\tA blog.marvel6.cn.\t30\tIN\tCNAME\tmbyd916.github.io. mbyd916.github.io.\t30\tIN\tA\t185.199.111.153 mbyd916.github.io.\t30\tIN\tA\t185.199.110.153 mbyd916.github.io.\t30\tIN\tA\t185.199.108.153 mbyd916.github.io.\t30\tIN\tA\t185.199.109.153 现在通过 https://blog.marvel6.cn 也可以访问啦\n参考 Hosting on GitHub Pages\nManaging a custom domain for your GitHub Pages site\n","id":5,"section":"posts","summary":"\u003ch3 id=\"背景\"\u003e背景\u003c/h3\u003e\n\u003cp\u003e我用Hugo生成的静态博客部署在腾讯云CVM上，只有一个实例，存在单点风险，也不能实现负载均衡。所以想托管在GitHub Pages，本文简单记录实现过程。\u003c/p\u003e","tags":["GitHub Pages","Hugo"],"title":"在 GitHub Pages 托管用 Hugo 创建的静态博客","uri":"https://blog.marvel6.cn/2019/12/hosting-hugo-blog-on-github-pages/","year":"2019"},{"content":"背景 fork了很多代码库，现在想批量删除，只保留自己创建的代码库。\n解决方法：\n使用Github提供的开发者API\n1. 创建token 登录Github，按导航 “Settings/Developer settings”，切换到Tab “Personal access tokens”， 新生成一个token。选择 scope， “delelete_repo”。一次性操作，建议scope尽可能设置小范围，并且操作后删除该token。\n2. 获取待删除repo列表 按导航“settings/repositories”，选取并复制所有repo，粘贴到一个文本文件，处理后得到一个自己准备删除的repo列表。\n3. 请求删库API # 创建的token GITHUB_SECRET=\u0026#34;\u0026#34; # Curl请求API删除指定repo function git_repo_delete(){ curl -vL \\ -H \u0026#34;Authorization: token $GITHUB_SECRET\u0026#34; \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -X DELETE https://api.github.com/repos/$1 } # helper: 获取指定范围内的一个随机整数 function mimvp_randnum_file() { min=$1 max=$2 mid=$(($max-$min+1)) num=$(head -n 20 /dev/urandom | cksum | cut -f1 -d \u0026#39; \u0026#39;) randnum=$(($num%$mid+$min)) echo $randnum } repos=$(cat \u0026lt;repo_file\u0026gt;) for repo in $repos do echo \u0026#34;deleting $repo ...\u0026#34; git_repo_delete \u0026#34;$repo\u0026#34; # 随机sleep，1～3秒 rand=$(mimvp_randnum_file 1 3) sleep $rand done 思考 批量删库，Github为啥没有采取措施，如短时间拒绝访问，或者封号呢？\n如果Github 账号被盗，风险还是很大的。。。\n","id":6,"section":"posts","summary":"\u003ch3 id=\"背景\"\u003e背景\u003c/h3\u003e\n\u003cp\u003efork了很多代码库，现在想批量删除，只保留自己创建的代码库。\u003c/p\u003e\n\u003cp\u003e解决方法：\u003c/p\u003e\n\u003cp\u003e使用Github提供的开发者API\u003c/p\u003e\n\u003ch3 id=\"1-创建token\"\u003e1. 创建token\u003c/h3\u003e\n\u003cp\u003e登录Github，按导航 “Settings/Developer settings”，切换到Tab “Personal access tokens”， 新生成一个token。选择 scope， “delelete_repo”。一次性操作，建议scope尽可能设置小范围，并且操作后删除该token。\u003c/p\u003e","tags":["Github删库","小工具"],"title":"批量删除自己的Github仓库","uri":"https://blog.marvel6.cn/2019/11/delete-my-github-repos-in-bulk/","year":"2019"},{"content":"你很可能从某种途径听说过 Go 语言。它越来越受欢迎，并且有充分的理由可以证明。 Go 快速、简单，有强大的社区支持。学习这门语言最令人兴奋的一点是它的并发模型。 Go 的并发原语使创建多线程并发程序变得简单而有趣。我将通过插图介绍 Go 的并发原语，希望能点透相关概念以方便后续学习。本文是写给 Go 语言编程新手以及准备开始学习 Go 并发原语 (go routines 和 channels) 的同学。\n单线程程序 vs. 多线程程序 你可能已经写过一些单线程程序。一个常用的编程模式是组合多个函数来执行一个特定任务，并且只有前一个函数准备好数据，后面的才会被调用。\n首先我们将用上述模式编写第一个例子的代码，一个描述挖矿的程序。它包含三个函数，分别负责执行寻矿、挖矿和练矿任务。在本例中，我们用一组字符串表示矿山和矿石，每个函数都以它们作为输入，并返回一组 “处理过的” 字符串。对于一个单线程的应用而言，该程序可能会按如下方式来设计：\n它有三个主要的函数：finder、miner 和 smelter。该版本的程序的所有函数都在单一线程中运行，一个接着一个执行，并且这个线程 (名为 Gary 的 gopher) 需要处理全部工作。\nfunc main() { theMine := [5]string{\u0026#34;rock\u0026#34;, \u0026#34;ore\u0026#34;, \u0026#34;ore\u0026#34;, \u0026#34;rock\u0026#34;, \u0026#34;ore\u0026#34;} foundOre := finder(theMine) minedOre := miner(foundOre) smelter(minedOre) } 在每个函数最后打印出 “矿石” 处理后的结果，得到如下输出：\nFrom Finder: [ore ore ore] From Miner: [minedOre minedOre minedOre] From Smelter: [smeltedOre smeltedOre smeltedOre] 这种编程风格具有易于设计的优点，但是当你想利用多个线程并执行彼此独立的函数时会发生什么呢？这就是并发程序设计发挥作用的地方。\n这种设计使得 “挖矿” 更高效。现在多个线程 (gophers) 是独立运行的，从而 Gary 不再承担全部工作。其中一个 gopher 负责寻矿，一个负责挖矿，另一个负责练矿，这些工作可能同时进行。\n为了将这种并发特性引入我们的代码，我们需要创建独立运行的 gophers 的方法以及它们之间彼此通信 (传送矿石) 的方法。这就需要用到 Go 的并发原语： goroutines 和 channels。\nGo routines Go routines 可以看作是轻量级线程。创建一个 Go routine 非常简单，只需要把 go 关键字放在函数调用语句前。为了说明这有多么简单，我们创建两个 finder 函数，并用 go 调用，让它们每次找到 “矿石” 就打印出来。\nfunc main() { theMine := [5]string{\u0026#34;rock\u0026#34;, \u0026#34;ore\u0026#34;, \u0026#34;ore\u0026#34;, \u0026#34;rock\u0026#34;, \u0026#34;ore\u0026#34;} go finder1(theMine) go finder2(theMine) \u0026lt;-time.After(time.Second * 5) //you can ignore this for now } 程序的输出如下:\nFinder 1 found ore! Finder 2 found ore! Finder 1 found ore! Finder 1 found ore! Finder 2 found ore! Finder 2 found ore! 可以看出，两个 finder 是并发运行的。哪一个先找到矿石没有确定的顺序，当执行多次程序时，这个顺序并不总是相同的。\n这是一个很大的进步！现在我们有一个简单的方法来创建多线程 (multi-gopher) 程序，但是当我们需要独立的 go routines 之间彼此通信会发生什么呢？欢迎来到神奇的 channels 世界。\nChannels Channels 允许 go routines 之间相互通信。你可以把 channel 看作管道，go routines 可以往里面发消息，也可以从中接收其它 go routines 的消息。\nmyFirstChannel := make(chan string) Go routines 可以往 channel 发送消息，也可以从中接收消息。这是通过箭头操作符 (\u0026lt;-) 完成的，它指示 channel 中的数据流向。\nmyFirstChannel \u0026lt;-\u0026#34;hello\u0026#34; // Send myVariable := \u0026lt;- myFirstChannel // Receive 现在通过 channel 我们可以让寻矿 gopher 一找到矿石就立即传送给开矿 gopher ，而不用等发现所有矿石。\n我重写了挖矿程序，把寻矿和开矿函数改写成了未命名函数。如果你从未见过 lambda 函数，不必过多关注这部分，只需要知道每个函数将通过 go 关键字调用并运行在各自的 go routine 中。重要的是，要注意 go routine 之间是如何通过 channel oreChan 传递数据的。别担心，我会在最后面解释未命名函数的。\nfunc main() { theMine := [5]string{\u0026#34;ore1\u0026#34;, \u0026#34;ore2\u0026#34;, \u0026#34;ore3\u0026#34;} oreChan := make(chan string) // Finder go func(mine [5]string) { for _, item := range mine { oreChan \u0026lt;- item //send } }(theMine) // Ore Breaker go func() { for i := 0; i \u0026lt; 3; i++ { foundOre := \u0026lt;-oreChan //receive fmt.Println(\u0026#34;Miner: Received \u0026#34; + foundOre + \u0026#34; from finder\u0026#34;) } }() \u0026lt;-time.After(time.Second * 5) // Again, ignore this for now } 从下面的输出，可以看到 Miner 从 oreChan 读取了三次，每次接收一块矿石。\nMiner: Received ore1 from finder Miner: Received ore2 from finder Miner: Received ore3 from finder 太棒了，现在我们能在程序的 go routines(gophers) 之间发送数据了。在开始用 channels 写复杂的程序之前，我们先来理解它的一些关键特性。\nChannel Blocking Channels 阻塞 go routines 发生在各种情形下。这能在 go routines 各自欢快地运行之前，实现彼此之间的短暂同步。\nBlocking on a Send 一旦一个 go routine(gopher) 向一个 channel 发送数据，它就被阻塞了，直到另一个 go routine 从该 channel 取走数据。\nBlocking on a Receive 和发送时情形类似，一个 go routine 可能阻塞着等待从一个 channel 获取数据，如果还没有其他 go routine 往该 channel 发送数据。\n一开始接触阻塞的概念可能令人有些困惑，但你可以把它想象成两个 go routines(gophers) 之间的交易。 其中一个 gopher 无论是等着收钱还是送钱，都需要等待交易的另一方出现。\n既然已经了解 go routine 通过 channel 通信可能发生阻塞的不同情形，让我们讨论两种不同类型的 channels: unbuffered 和 buffered 。选择使用哪一种 channel 可能会改变程序的运行表现。\nUnbuffered Channels 在前面的例子中我们一直在用 unbuffered channels，它们与众不同的地方在于每次只有一份数据可以通过。\nBuffered Channels 在并发程序中，时间协调并不总是完美的。在挖矿的例子中，我们可能遇到这样的情形：开矿 gopher 处理一块矿石所花的时间，寻矿 gohper 可能已经找到 3 块矿石了。为了不让寻矿 gopher 浪费大量时间等着给开矿 gopher 传送矿石，我们可以使用 buffered channel。我们先创建一个容量为 3 的 buffered channel。\nbufferedChan := make(chan string, 3) buffered 和 unbuffered channels 工作原理类似，但有一点不同—在需要另一个 go rountine 取走数据之前，我们可以向 buffered channel 发送多份数据。\nbufferedChan := make(chan string, 3) go func() { bufferedChan \u0026lt;-\u0026#34;first\u0026#34; fmt.Println(\u0026#34;Sent 1st\u0026#34;) bufferedChan \u0026lt;-\u0026#34;second\u0026#34; fmt.Println(\u0026#34;Sent 2nd\u0026#34;) bufferedChan \u0026lt;-\u0026#34;third\u0026#34; fmt.Println(\u0026#34;Sent 3rd\u0026#34;) }() \u0026lt;-time.After(time.Second * 1) go func() { firstRead := \u0026lt;- bufferedChan fmt.Println(\u0026#34;Receiving..\u0026#34;) fmt.Println(firstRead) secondRead := \u0026lt;- bufferedChan fmt.Println(secondRead) thirdRead := \u0026lt;- bufferedChan fmt.Println(thirdRead) }() 两个 go routines 之间的打印顺序如下：\nSent 1st Sent 2nd Sent 3rd Receiving.. first second third 为了简单起见，我们在最终的程序中不使用 buffered channels。但知道该使用哪种 channel 是很重要的。\n注意: 使用 buffered channels 并不会避免阻塞发生。例如，如果寻矿 gopher 比开矿 gopher 执行速度快 10 倍，并且它们通过一个容量为 2 的 buffered channel 进行通信，那么寻矿 gopher 仍会发生多次阻塞。\n把这些都放到一起 现在凭借 go routines 和 channels 的强大功能，我们可以使用 Go 的并发原语编写一个充分发挥多线程优势的程序了。\ntheMine := [5]string{\u0026#34;rock\u0026#34;, \u0026#34;ore\u0026#34;, \u0026#34;ore\u0026#34;, \u0026#34;rock\u0026#34;, \u0026#34;ore\u0026#34;} oreChannel := make(chan string) minedOreChan := make(chan string) // Finder go func(mine [5]string) { for _, item := range mine { if item == \u0026#34;ore\u0026#34; { oreChannel \u0026lt;- item //send item on oreChannel } } }(theMine) // Ore Breaker go func() { for i := 0; i \u0026lt; 3; i++ { foundOre := \u0026lt;-oreChannel //read from oreChannel fmt.Println(\u0026#34;From Finder:\u0026#34;, foundOre) minedOreChan \u0026lt;-\u0026#34;minedOre\u0026#34; //send to minedOreChan } }() // Smelter go func() { for i := 0; i \u0026lt; 3; i++ { minedOre := \u0026lt;-minedOreChan //read from minedOreChan fmt.Println(\u0026#34;From Miner:\u0026#34;, minedOre) fmt.Println(\u0026#34;From Smelter: Ore is smelted\u0026#34;) } }() \u0026lt;-time.After(time.Second * 5) // Again, you can ignore this 程序输出如下：\nFrom Finder: ore From Finder: ore From Miner: minedOre From Smelter: Ore is smelted From Miner: minedOre From Smelter: Ore is smelted From Finder: ore From Miner: minedOre From Smelter: Ore is smelted 相比最初的例子，已经有了很大改进！现在每个函数都独立地运行在各自的 go routines 中。此外，每次处理完一块矿石，它就会被带进挖矿流水线的下一个阶段。\n为了专注于理解 go routines 和 channel 的基本概念，上文有些重要的信息我没有提，如果不知道的话，当你开始编程时它们可能会造成一些麻烦。既然你已经理解了 go routines 和 channel 的工作原理，在开始用它们编写代码之前，让我们先了解一些你应该知道的其他信息。\n在开始之前，你应该知道\u0026hellip; 匿名的 Go routines 类似于如何利用 go 关键字使一个函数运行在自己的 go routine 中，我们可以用如下方式创建一个匿名函数并运行在它的 go routine 中：\n// Anonymous go routine go func() { fmt.Println(\u0026#34;I\u0026#39;m running in my own go routine\u0026#34;) }() 如果只需要调用一次函数，通过这种方式我们可以让它在自己的 go routine 中运行，而不需要创建一个正式的函数声明。\nmain 函数是一个 go routine main 函数确实运行在自己的 go routine 中！更重要的是要知道，一旦 main 函数返回，它将关掉当前正在运行的其他 go routines。这就是为什么我们在 main 函数的最后设置了一个定时器—它创建了一个 channel，并在 5 秒后发送一个值。\n\u0026lt;-time.After(time.Second * 5) //Receiving from channel after 5 sec 还记得 go routine 从 channel 中读数据如何被阻塞直到有数据发送到里面吧？通过添加上面这行代码，main routine 将会发生这种情况。它会阻塞，以给其他 go routines 5 秒的时间来运行。\n现在有更好的方式阻塞 main 函数直到其他所有 go routines 都运行完。通常的做法是创建一个 done channel， main 函数在等待读取它时被阻塞。一旦完成工作，向这个 channel 发送数据，程序就会结束了。\nfunc main() { doneChan := make(chan string) go func() { // Do some work… doneChan \u0026lt;- \u0026#34;I\u0026#39;m all done!\u0026#34; }() \u0026lt;-doneChan // block until go routine signals work is done } 你可以遍历 channel 在前面的例子中我们让 miner 在 for 循环中迭代 3 次从 channel 中读取数据。如果我们不能确切知道将从 finder 接收多少块矿石呢？ 好吧，类似于对集合数据类型 (注: 如 slice) 进行遍历，你也可以遍历一个 channel。\n更新前面的 miner 函数，我们可以这样写：\n// Ore Breaker go func() { for foundOre := range oreChan { fmt.Println(\u0026#34;Miner: Received \u0026#34; + foundOre + \u0026#34; from finder\u0026#34;) } }() 由于 miner 需要读取 finder 发送给它的所有数据，遍历 channel 能确保我们接收到已经发送的所有数据。\n遍历 channel 会阻塞，直到有新数据被发送到 channel。在所有数据发送完之后避免 go routine 阻塞的唯一方法就是用 \u0026ldquo;close(channel)\u0026rdquo; 关掉 channel。\n对 channel 进行非阻塞读 但你刚刚告诉我们 channel 如何阻塞 go routine 的各种情形？！没错，不过还有一个技巧，利用 Go 的 select case 语句可以实现对 channel 的非阻塞读。通过使用这这种语句，如果 channel 有数据，go routine 将会从中读取，否则就执行默认的分支。\nmyChan := make(chan string) go func(){ myChan \u0026lt;- \u0026#34;Message!\u0026#34; }() select { case msg := \u0026lt;- myChan: fmt.Println(msg) default: fmt.Println(\u0026#34;No Msg\u0026#34;) } \u0026lt;-time.After(time.Second * 1) select { case msg := \u0026lt;- myChan: fmt.Println(msg) default: fmt.Println(\u0026#34;No Msg\u0026#34;) } 程序输出如下:\nNo Msg Message! 对 channel 进行非阻塞写 非阻塞写也是使用同样的 select case 语句来实现，唯一不同的地方在于，case 语句看起来像是发送而不是接收。\nselect { case myChan \u0026lt;- \u0026#34;message\u0026#34;: fmt.Println(\u0026#34;sent the message\u0026#34;) default: fmt.Println(\u0026#34;no message sent\u0026#34;) } 接下来去哪儿学 有许多讲座和博客更详细地介绍了 channels 和 go routines。 既然已经对这些工具的目的和应用有了深刻的理解，那么你应该能够充分利用下面的文章和演讲了。\nGoogle I/O 2012 — Go Concurrency Patterns\nRob Pike — \u0026lsquo;Concurrency Is Not Parallelism\u0026rsquo;\nGopherCon 2017: Edward Muller — Go Anti-Patterns\n谢谢您花时间阅读本文。我希望你能够理解 go routines 和 channels 基本概念，以及使用它们给编写并发程序带来的好处。\nvia: https://medium.com/@trevor4e/learning-gos-concurrency-through-illustrations-8c4aff603b3\n作者：Trevor Forrey 译者：mbyd916\n","id":7,"section":"posts","summary":"\u003cp\u003e你很可能从某种途径听说过 Go 语言。它越来越受欢迎，并且有充分的理由可以证明。 Go 快速、简单，有强大的社区支持。学习这门语言最令人兴奋的一点是它的并发模型。 Go 的并发原语使创建多线程并发程序变得简单而有趣。我将通过插图介绍 Go 的并发原语，希望能点透相关概念以方便后续学习。本文是写给 Go 语言编程新手以及准备开始学习 Go 并发原语 (go routines 和 channels) 的同学。\u003c/p\u003e","tags":["Goroutine","Channel"],"title":"图解 Go 并发编程","uri":"https://blog.marvel6.cn/2019/02/learning-go-concurrency-through-illustrations/","year":"2019"},{"content":"slice 表示底层数组的一个分片，内部数据结构包含三个字段：指向底层数组的指针 (ptr)、数组分片的长度 (len) 和底层数组大小 (cap) ，示意图如下：\n1. 初步了解 首先通过变量声明来认识下 nil slice 和 empty slice:\nvar s []int\t// 【1】 var t = []int{}\t// 【2】 fmt.Printf(\u0026#34;value of s: %#v\\n\u0026#34;, s) fmt.Printf(\u0026#34;value of t: %#v\\n\u0026#34;, t) /* output // value of s: []int(nil) // value of t: []int{} */ 语句【1】声明了一个[]int类型的变量， 其值为[]int(nil)，这就是 nil slice，表示 slice 类型的 zero value。 语句【2】声明并定义了一个[]int类型的变量，其值为[]int{}，这就是 empty slice。\nfmt.Printf(\u0026#34;s: len=%d, cap=%d\\n\u0026#34;, len(s), cap(s))\t// 【3】 fmt.Printf(\u0026#34;t: len=%d, cap=%d\\n\u0026#34;, len(t), cap(t))\t// 【4】 /* output // s: len=0, cap=0 // t: len=0, cap=0 */ 从语句【3】和【4】输出结果来看，这两种 slice 的 len 和 cap 字段值都为0。\n接下来将它们分别和nil进行比较：\nfmt.Printf(\u0026#34;s is nil? %v\\n\u0026#34;, s == nil) // 【5】 fmt.Printf(\u0026#34;t is nil? %v\\n\u0026#34;, t == nil) // 【6】 /* output // s is nil? true // t is nil? false */ 语句【5】和【6】输出结果表明 nil slice 的值等于 nil，而 empty slice 则不等于。\n2. 数据结构 再看下这两种 slice 内部数据结构的表示：\nnil slice 数据结构示意图 empty slice 数据结构示意图 nil slice 没有底层数组（ptr 指针为 nil），empty slice 有底层数组，不过数组大小是 0 。\n3. 习惯用法 nil slice 常用来表示 slice 不存在，如实现一个要求返回 slice 类型的函数，当执行流程出现异常，可以提前返回一个 nil slice 和 error。\nempty slice 常用来表示空集合，如用来表示 db 查询返回的结果集为空。\n多数情况下，两种 slice 可以相互替换，但有些使用场景需要注意区分，比如对 JSON 对象进行编码。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;encoding/json\u0026#34; ) type A struct { Data []string } func main() { var nilSlice []string var emptySlice = []string{} b, _ := json.Marshal(A{nilSlice}) fmt.Printf(\u0026#34;%s\\n\u0026#34;, b) b, _ = json.Marshal(A{emptySlice}) fmt.Printf(\u0026#34;%s\\n\u0026#34;, b) /* output // {\u0026#34;Data\u0026#34;:null} // {\u0026#34;Data\u0026#34;:[]} */ } nil slice 被编码成 null，而 empty slice 被编码成 []，在设计 API 时要注意这点，前端需要进行不同的处理。\n4. 参考文档 (1) Go Slices: usage and internals\n(2) Go: Empty slice vs. nil slice\n(3) Empty slice vs nil slice in GoLang\n(4) The zero value of a slice is not nil\n","id":8,"section":"posts","summary":"\u003cp\u003eslice 表示底层数组的一个分片，内部数据结构包含三个字段：指向底层数组的指针 (ptr)、数组分片的长度 (len) 和底层数组大小 (cap) ，示意图如下：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/slice_internal.png\" alt=\"slice 数据结构示意图\"\u003e\u003c/p\u003e","tags":["slice"],"title":"Golang 笔记之 nil slice 和 empty slice","uri":"https://blog.marvel6.cn/2018/11/golang-nil-empty-slice/","year":"2018"},{"content":"检测 Go 程序中按值传递的 locks go tool vet -copylocks 命令简介\nGo 语言安装包附带 vet 命令行工具。该工具能对程序源码运行一套启发式算法以发现可疑的程序结构，如无法执行的代码或对 fmt.Printf 函数的错误调用（指 arguments 没有对齐 format 参数）：\npackage main import \u0026#34;fmt\u0026#34; func f() { fmt.Printf(\u0026#34;%d\\n\u0026#34;) return fmt.Println(\u0026#34;Done\u0026#34;) } \u0026gt; go tool vet vet.go vet.go:8: unreachable code vet.go:6: missing argument for Printf(\u0026#34;%d\u0026#34;): format reads arg 1, have only 0 args 本文专讲该工具的 copylocks 选项。让我们看看它能做什么以及如何在实际的程序中发挥作用。\n假设程序使用互斥锁进行同步：\npackage main import \u0026#34;sync\u0026#34; type T struct { lock sync.Mutex } func (t *T) Lock() { t.lock.Lock() } func (t T) Unlock() { t.lock.Unlock() } func main() { t := T{lock: sync.Mutex{}} t.Lock() t.Unlock() t.Lock() } 如果变量 v 是可寻址的，并且 \u0026amp;v 的方法集合包含 m，那么 v.m() 是 (\u0026amp;v).m() 的简写。\n想一想上述程序运行的结果可能是什么\u0026hellip;\n程序会进入死锁状态：\nfatal error: all goroutines are asleep — deadlock! goroutine 1 [semacquire]: sync.runtime_Semacquire(0x4201162ac) /usr/local/go/src/runtime/sema.go:47 +0x30 sync.(*Mutex).Lock(0x4201162a8) /usr/local/go/src/sync/mutex.go:85 +0xd0 main.(*T).Lock(0x4201162a8) ... 运行上述程序得到了糟糕的结果，根本原因是把 receiver 按值传递给 Unlock 方法，所以 t.lock.Unlock() 实际上是由 lock 的副本调用的。我们很容易忽视这点，特别在更大型的程序中。Go 编译器不会检测这方面，因为这可能是程序员有意为之。该 vet 工具登场啦\u0026hellip;\n\u0026gt; go tool vet vet.go vet.go:13: Unlock passes lock by value: main.T 选项 copylocks (默认启用) 会检测拥有 Lock 方法 (实际需要 pointer receiver) 的 type 是否按值传递。如果是这种情况，则会发出警告。\nsync 包有使用该机制的例子，它有一个命名为 noCopy 的特殊 type。为了避免某 type 按值拷贝 (实际上通过 vet 工具进行检测)，需要往 struct 定义中添加一个 field(如 WaitGroup):\npackage main import \u0026#34;sync\u0026#34; type T struct { wg sync.WaitGroup } func fun(T) {} func main() { t := T{sync.WaitGroup{}} fun(t) } \u0026gt; go tool vet lab.go lab.go:9: fun passes lock by value: main.T contains sync.WaitGroup contains sync.noCopy lab.go:13: function call copies lock value: main.T contains sync.WaitGroup contains sync.noCopy 深入理解该机制\nvet 工具的源文件放在 /src/cmd/vet 路径下。vet 的每个选项都利用 register 函数进行注册，该函数其中两个参数分别是一个可变参数 (类型是该选项所关注的 AST 结点类型) 和一个回调函数。该回调函数将因特定类型的结点事件触发。对于 copylocks 选项，需要检测的结点包含 return 语句。最终都会转到 lockPath，它验证传递的值是否属于某个 type(拥有一个需要 pointer receiver 的 Lock 方法)。在整个处理过程中，go/ast 包被广泛使用。可以在 Go 源码可测试的示例中找到对该包的简单介绍。\n多点击下方的 \u0026ldquo;👏\u0026rdquo; 按钮， 以帮助其他人找到这篇文章哦。如果您想获得有关新帖子的更新或未来工作进展的消息， 请在这儿或者 Twitter 上关注我。\nvia: https://medium.com/golangspec/detect-locks-passed-by-value-in-go-efb4ac9a3f2b\n作者：Michał Łowicki 译者：mbyd916\n","id":9,"section":"posts","summary":"\u003ch1 id=\"检测-go-程序中按值传递的-locks\"\u003e检测 Go 程序中按值传递的 locks\u003c/h1\u003e\n\u003cp\u003e\u003ccode\u003ego tool vet -copylocks\u003c/code\u003e 命令简介\u003c/p\u003e\n\u003cp\u003eGo 语言安装包附带 \u003ca href=\"https://golang.org/cmd/vet/\"\u003evet\u003c/a\u003e 命令行工具。该工具能对程序源码运行一套启发式算法以发现可疑的程序结构，如无法执行的代码或对 \u003ccode\u003efmt.Printf\u003c/code\u003e 函数的错误调用（指 arguments 没有对齐 format 参数）：\u003c/p\u003e","tags":["gotool","lock"],"title":"检测 Go 程序中按值传递的 locks","uri":"https://blog.marvel6.cn/2018/08/detect-locks-passed-by-value-in-go/","year":"2018"}],"tags":[{"title":"Channel","uri":"https://blog.marvel6.cn/tags/channel/"},{"title":"GitHub Pages","uri":"https://blog.marvel6.cn/tags/github-pages/"},{"title":"Github删库","uri":"https://blog.marvel6.cn/tags/github%E5%88%A0%E5%BA%93/"},{"title":"Goconvey","uri":"https://blog.marvel6.cn/tags/goconvey/"},{"title":"Goroutine","uri":"https://blog.marvel6.cn/tags/goroutine/"},{"title":"Gotool","uri":"https://blog.marvel6.cn/tags/gotool/"},{"title":"Hugo","uri":"https://blog.marvel6.cn/tags/hugo/"},{"title":"Hystrix 配置","uri":"https://blog.marvel6.cn/tags/hystrix-%E9%85%8D%E7%BD%AE/"},{"title":"Lock","uri":"https://blog.marvel6.cn/tags/lock/"},{"title":"Slice","uri":"https://blog.marvel6.cn/tags/slice/"},{"title":"Sqlmock","uri":"https://blog.marvel6.cn/tags/sqlmock/"},{"title":"Xorm","uri":"https://blog.marvel6.cn/tags/xorm/"},{"title":"功能测试","uri":"https://blog.marvel6.cn/tags/%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95/"},{"title":"动态规划","uri":"https://blog.marvel6.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"title":"小工具","uri":"https://blog.marvel6.cn/tags/%E5%B0%8F%E5%B7%A5%E5%85%B7/"},{"title":"数学","uri":"https://blog.marvel6.cn/tags/%E6%95%B0%E5%AD%A6/"},{"title":"熔断降级","uri":"https://blog.marvel6.cn/tags/%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7/"},{"title":"错误处理","uri":"https://blog.marvel6.cn/tags/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"}]}